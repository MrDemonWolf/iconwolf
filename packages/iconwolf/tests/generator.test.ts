import fs from 'node:fs';
import path from 'node:path';
import sharp from 'sharp';
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { generate } from '../src/generator.js';
import { OUTPUT_FILES } from '../src/utils/paths.js';
import { createTestPng, createTmpDir, cleanDir } from './helpers.js';

let tmpDir: string;
let testPng: string;
let testIconFolder: string;

async function createMockIconFolder(dir: string): Promise<string> {
  const iconDir = path.join(dir, 'Test.icon');
  const assetsDir = path.join(iconDir, 'Assets');
  fs.mkdirSync(assetsDir, { recursive: true });

  await sharp({
    create: {
      width: 200,
      height: 200,
      channels: 4,
      background: { r: 255, g: 107, b: 53, alpha: 255 },
    },
  })
    .png()
    .toFile(path.join(assetsDir, 'logo.png'));

  fs.writeFileSync(
    path.join(iconDir, 'icon.json'),
    JSON.stringify({
      fill: {
        'linear-gradient': [
          'display-p3:0.00000,0.67451,0.92941,1.00000',
          'display-p3:0.03529,0.08235,0.20000,1.00000',
        ],
        orientation: { start: { x: 0.5, y: 0 }, stop: { x: 0.5, y: 0.7 } },
      },
      groups: [
        {
          layers: [
            {
              'image-name': 'logo.png',
              name: 'logo',
              position: { scale: 1.0, 'translation-in-points': [0, 0] },
            },
          ],
        },
      ],
    }),
  );

  return iconDir;
}

beforeAll(async () => {
  tmpDir = createTmpDir();
  testPng = await createTestPng(1024, 1024, tmpDir);
  testIconFolder = await createMockIconFolder(tmpDir);
});

afterAll(() => {
  cleanDir(tmpDir);
});

describe('generate', () => {
  it('generates 4 default files when no flags set (matches Expo template)', async () => {
    const outDir = path.join(tmpDir, 'all');

    await generate({
      inputPath: testPng,
      outputDir: outDir,
      variants: { android: false, favicon: false, splash: false, icon: false },
      bgColor: '#FFFFFF',
    });

    expect(fs.existsSync(path.join(outDir, OUTPUT_FILES.icon))).toBe(true);
    expect(
      fs.existsSync(path.join(outDir, OUTPUT_FILES.androidForeground)),
    ).toBe(true);
    expect(fs.existsSync(path.join(outDir, OUTPUT_FILES.splashIcon))).toBe(
      true,
    );
    expect(fs.existsSync(path.join(outDir, OUTPUT_FILES.favicon))).toBe(true);
    // Background and monochrome NOT generated by default
    expect(
      fs.existsSync(path.join(outDir, OUTPUT_FILES.androidBackground)),
    ).toBe(false);
    expect(
      fs.existsSync(path.join(outDir, OUTPUT_FILES.androidMonochrome)),
    ).toBe(false);
  });

  it('generates only icon when --icon flag set', async () => {
    const outDir = path.join(tmpDir, 'icon-only');

    await generate({
      inputPath: testPng,
      outputDir: outDir,
      variants: { android: false, favicon: false, splash: false, icon: true },
      bgColor: '#FFFFFF',
    });

    expect(fs.existsSync(path.join(outDir, 'icon.png'))).toBe(true);
    expect(fs.existsSync(path.join(outDir, 'favicon.png'))).toBe(false);
    expect(fs.existsSync(path.join(outDir, 'splash-icon.png'))).toBe(false);
    expect(fs.existsSync(path.join(outDir, 'adaptive-icon.png'))).toBe(false);
  });

  it('generates all android files when --android flag set', async () => {
    const outDir = path.join(tmpDir, 'android-only');

    await generate({
      inputPath: testPng,
      outputDir: outDir,
      variants: { android: true, favicon: false, splash: false, icon: false },
      bgColor: '#FFFFFF',
    });

    expect(fs.existsSync(path.join(outDir, 'adaptive-icon.png'))).toBe(true);
    expect(
      fs.existsSync(path.join(outDir, 'android-icon-background.png')),
    ).toBe(true);
    expect(fs.existsSync(path.join(outDir, 'monochrome-icon.png'))).toBe(true);
    expect(fs.existsSync(path.join(outDir, 'icon.png'))).toBe(false);
    expect(fs.existsSync(path.join(outDir, 'favicon.png'))).toBe(false);
  });

  it('throws on missing source file', async () => {
    const outDir = path.join(tmpDir, 'missing');

    await expect(
      generate({
        inputPath: '/tmp/does-not-exist.png',
        outputDir: outDir,
        variants: {
          android: false,
          favicon: false,
          splash: false,
          icon: false,
        },
        bgColor: '#FFFFFF',
      }),
    ).rejects.toThrow('Source not found');
  });

  it('generates 4 default files from .icon folder', async () => {
    const outDir = path.join(tmpDir, 'icon-composer');

    await generate({
      inputPath: testIconFolder,
      outputDir: outDir,
      variants: { android: false, favicon: false, splash: false, icon: false },
      bgColor: '#FFFFFF',
    });

    expect(fs.existsSync(path.join(outDir, OUTPUT_FILES.icon))).toBe(true);
    expect(
      fs.existsSync(path.join(outDir, OUTPUT_FILES.androidForeground)),
    ).toBe(true);
    expect(fs.existsSync(path.join(outDir, OUTPUT_FILES.splashIcon))).toBe(
      true,
    );
    expect(fs.existsSync(path.join(outDir, OUTPUT_FILES.favicon))).toBe(true);
    expect(
      fs.existsSync(path.join(outDir, OUTPUT_FILES.androidBackground)),
    ).toBe(false);
    expect(
      fs.existsSync(path.join(outDir, OUTPUT_FILES.androidMonochrome)),
    ).toBe(false);

    // Verify the composed icon is 1024x1024
    const meta = await sharp(path.join(outDir, 'icon.png')).metadata();
    expect(meta.width).toBe(1024);
    expect(meta.height).toBe(1024);
  });

  it('creates output directory if it does not exist', async () => {
    const outDir = path.join(tmpDir, 'nested', 'deep', 'dir');

    await generate({
      inputPath: testPng,
      outputDir: outDir,
      variants: { android: false, favicon: false, splash: false, icon: true },
      bgColor: '#FFFFFF',
    });

    expect(fs.existsSync(outDir)).toBe(true);
    expect(fs.existsSync(path.join(outDir, 'icon.png'))).toBe(true);
  });

  it('generates only favicon when --favicon flag set', async () => {
    const outDir = path.join(tmpDir, 'favicon-only');

    await generate({
      inputPath: testPng,
      outputDir: outDir,
      variants: { android: false, favicon: true, splash: false, icon: false },
      bgColor: '#FFFFFF',
    });

    expect(fs.existsSync(path.join(outDir, 'favicon.png'))).toBe(true);
    expect(fs.existsSync(path.join(outDir, 'icon.png'))).toBe(false);
    expect(fs.existsSync(path.join(outDir, 'splash-icon.png'))).toBe(false);
    expect(fs.existsSync(path.join(outDir, 'adaptive-icon.png'))).toBe(false);
  });

  it('generates only splash when --splash flag set', async () => {
    const outDir = path.join(tmpDir, 'splash-only');

    await generate({
      inputPath: testPng,
      outputDir: outDir,
      variants: { android: false, favicon: false, splash: true, icon: false },
      bgColor: '#FFFFFF',
    });

    expect(fs.existsSync(path.join(outDir, 'splash-icon.png'))).toBe(true);
    expect(fs.existsSync(path.join(outDir, 'icon.png'))).toBe(false);
    expect(fs.existsSync(path.join(outDir, 'favicon.png'))).toBe(false);
    expect(fs.existsSync(path.join(outDir, 'adaptive-icon.png'))).toBe(false);
  });

  it('generates multiple variants when multiple flags set', async () => {
    const outDir = path.join(tmpDir, 'multi-flags');

    await generate({
      inputPath: testPng,
      outputDir: outDir,
      variants: { android: true, favicon: true, splash: false, icon: false },
      bgColor: '#FFFFFF',
    });

    expect(fs.existsSync(path.join(outDir, 'adaptive-icon.png'))).toBe(true);
    expect(
      fs.existsSync(path.join(outDir, 'android-icon-background.png')),
    ).toBe(true);
    expect(fs.existsSync(path.join(outDir, 'monochrome-icon.png'))).toBe(true);
    expect(fs.existsSync(path.join(outDir, 'favicon.png'))).toBe(true);
    expect(fs.existsSync(path.join(outDir, 'icon.png'))).toBe(false);
    expect(fs.existsSync(path.join(outDir, 'splash-icon.png'))).toBe(false);
  });

  it('uses custom bg-color for .icon folder when provided', async () => {
    const outDir = path.join(tmpDir, 'icon-custom-bg');

    await generate({
      inputPath: testIconFolder,
      outputDir: outDir,
      variants: { android: true, favicon: false, splash: false, icon: false },
      bgColor: '#FF0000',
    });

    expect(
      fs.existsSync(path.join(outDir, 'android-icon-background.png')),
    ).toBe(true);

    const { channels } = await sharp(
      path.join(outDir, 'android-icon-background.png'),
    ).stats();
    expect(channels[0].mean).toBeCloseTo(255, -1); // Red
    expect(channels[1].mean).toBeCloseTo(0, -1); // Green
    expect(channels[2].mean).toBeCloseTo(0, -1); // Blue
  });

  it('cleans up temp composed image from .icon folder', async () => {
    const os = await import('node:os');
    const outDir = path.join(tmpDir, 'icon-cleanup');

    // Count compose dirs before
    const composeDirsBefore = fs
      .readdirSync(os.tmpdir())
      .filter((d) => d.startsWith('iconwolf-compose-'));

    await generate({
      inputPath: testIconFolder,
      outputDir: outDir,
      variants: { android: false, favicon: false, splash: false, icon: true },
      bgColor: '#FFFFFF',
    });

    // No new compose dirs should remain after generation
    const composeDirsAfter = fs
      .readdirSync(os.tmpdir())
      .filter((d) => d.startsWith('iconwolf-compose-'));
    expect(composeDirsAfter.length).toBeLessThanOrEqual(
      composeDirsBefore.length,
    );

    expect(fs.existsSync(path.join(outDir, 'icon.png'))).toBe(true);
  });

  it('throws on directory that is not a .icon folder or PNG', async () => {
    const fakeDir = path.join(tmpDir, 'not-icon-dir');
    fs.mkdirSync(fakeDir, { recursive: true });
    fs.writeFileSync(path.join(fakeDir, 'dummy.txt'), 'test');

    await expect(
      generate({
        inputPath: fakeDir,
        outputDir: path.join(tmpDir, 'err-out'),
        variants: {
          android: false,
          favicon: false,
          splash: false,
          icon: false,
        },
        bgColor: '#FFFFFF',
      }),
    ).rejects.toThrow();
  });

  it('favicon has rounded corners with transparent pixels', async () => {
    const outDir = path.join(tmpDir, 'favicon-corners');

    await generate({
      inputPath: testPng,
      outputDir: outDir,
      variants: { android: false, favicon: true, splash: false, icon: false },
      bgColor: '#FFFFFF',
    });

    const faviconPath = path.join(outDir, 'favicon.png');
    expect(fs.existsSync(faviconPath)).toBe(true);

    const { data, info } = await sharp(faviconPath)
      .raw()
      .toBuffer({ resolveWithObject: true });

    // Top-left corner should be transparent (rounded)
    expect(data[3]).toBe(0); // alpha of pixel (0,0)
    expect(info.channels).toBe(4);
  });

  it('uses separate splash input when --splash-input provided', async () => {
    const outDir = path.join(tmpDir, 'splash-input');
    const splashPng = await createTestPng(512, 512, tmpDir, 'splash-src.png');

    await generate({
      inputPath: testPng,
      outputDir: outDir,
      variants: { android: false, favicon: false, splash: true, icon: false },
      bgColor: '#FFFFFF',
      splashInputPath: splashPng,
    });

    expect(fs.existsSync(path.join(outDir, 'splash-icon.png'))).toBe(true);
  });

  it('applies banner to icon, adaptive-icon, and splash but not favicon', async () => {
    const outDir = path.join(tmpDir, 'banner-test');

    const results = await generate({
      inputPath: testPng,
      outputDir: outDir,
      variants: { android: false, favicon: false, splash: false, icon: false },
      bgColor: '#FFFFFF',
      banner: { text: 'DEV' },
    });

    // All 4 default files should exist
    expect(fs.existsSync(path.join(outDir, OUTPUT_FILES.icon))).toBe(true);
    expect(fs.existsSync(path.join(outDir, OUTPUT_FILES.favicon))).toBe(true);
    expect(fs.existsSync(path.join(outDir, OUTPUT_FILES.splashIcon))).toBe(true);
    expect(
      fs.existsSync(path.join(outDir, OUTPUT_FILES.androidForeground)),
    ).toBe(true);
    expect(results.length).toBe(4);
  });

  it('skips banner on background and monochrome android variants', async () => {
    const outDir = path.join(tmpDir, 'banner-android');

    const results = await generate({
      inputPath: testPng,
      outputDir: outDir,
      variants: { android: true, favicon: false, splash: false, icon: false },
      bgColor: '#FFFFFF',
      banner: { text: 'STAGING', color: '#2196F3' },
    });

    // adaptive-icon.png should exist (banner applied)
    expect(
      fs.existsSync(path.join(outDir, OUTPUT_FILES.androidForeground)),
    ).toBe(true);
    // background and monochrome should exist (no banner)
    expect(
      fs.existsSync(path.join(outDir, OUTPUT_FILES.androidBackground)),
    ).toBe(true);
    expect(
      fs.existsSync(path.join(outDir, OUTPUT_FILES.androidMonochrome)),
    ).toBe(true);
    expect(results.length).toBe(3);
  });

  it('throws on missing splash input file', async () => {
    const outDir = path.join(tmpDir, 'splash-missing');

    await expect(
      generate({
        inputPath: testPng,
        outputDir: outDir,
        variants: {
          android: false,
          favicon: false,
          splash: true,
          icon: false,
        },
        bgColor: '#FFFFFF',
        splashInputPath: '/tmp/nonexistent-splash.png',
      }),
    ).rejects.toThrow('Splash source not found');
  });
});
